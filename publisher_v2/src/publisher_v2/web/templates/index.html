<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>{{ web_ui_text.title or "Publisher V2 Web" }}</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      background-color: #0f172a;
      color: #e5e7eb;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      transition: background-color 0.2s ease;
    }
    body.admin-mode {
      background-color: #8b0000;
    }
    header {
      padding: 0.75rem 1rem;
      background-color: #020617;
      border-bottom: 1px solid #1f2937;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
    }
    header h1 {
      font-size: 1.1rem;
      margin: 0;
    }
    .header-left,
    .header-right {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    main {
      flex: 1;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      max-width: 960px;
      width: 100%;
      margin: 0 auto;
    }
    .mode-toggle {
      display: flex;
      justify-content: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }
    .mode-btn {
      flex: 0 1 auto;
      padding: 0.5rem 1rem;
      font-size: 0.85rem;
      border-radius: 9999px;
      border: 1px solid #374151;
      background: #1e293b;
      color: #9ca3af;
      cursor: pointer;
      transition: all 0.2s;
    }
    .mode-btn.active {
      background: #3b82f6;
      color: white;
      border-color: #3b82f6;
    }
    .image-container {
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #020617;
      border-radius: 0.75rem;
      padding: 0.75rem;
      border: 1px solid #1f2937;
      max-width: min(100%, 1280px);
      width: 100%;
      margin: 0 auto;
      transition: transform 0.15s ease-out, opacity 0.15s ease-out;
      position: relative;
    }
    .image-placeholder {
      text-align: center;
      font-size: 0.95rem;
      color: #9ca3af;
      padding: 1.5rem 1rem;
    }
    .image-container img {
      max-width: 100%;
      height: auto;
      border-radius: 0.5rem;
      object-fit: contain;
    }
    .image-container.swiping-left {
      transform: translateX(-20px);
      opacity: 0.7;
    }
    .image-container.swiping-right {
      transform: translateX(20px);
      opacity: 0.7;
    }
    .controls {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    button {
      flex: 1 1 30%;
      padding: 0.75rem;
      border-radius: 9999px;
      border: none;
      font-size: 0.95rem;
      font-weight: 500;
      cursor: pointer;
      color: #0f172a;
      background: linear-gradient(to right, #38bdf8, #22c55e);
    }
    button.secondary {
      background: #111827;
      color: #e5e7eb;
      border: 1px solid #374151;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }
    .panel {
      background-color: #020617;
      border-radius: 0.75rem;
      padding: 0.75rem;
      border: 1px solid #1f2937;
      font-size: 0.9rem;
    }
    .panel h2 {
      font-size: 0.95rem;
      margin-top: 0;
    }
    .status {
      font-size: 0.85rem;
      color: #9ca3af;
      min-height: 1.2rem;
    }
    code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.8rem;
    }
    .hidden {
      display: none !important;
    }
    .admin-only {
      /* marker class; actual visibility controlled via .hidden */
    }
    /* Simple modal styles */
    .modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: rgba(15, 23, 42, 0.8);
      z-index: 50;
    }
    .modal-dialog {
      background-color: #020617;
      border-radius: 0.75rem;
      padding: 1rem;
      border: 1px solid #1f2937;
      width: 100%;
      max-width: 22rem;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
    }
    .modal-dialog h2 {
      margin-top: 0;
      font-size: 1rem;
    }
    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }
  </style>
</head>
<body>
  <header>
    <div class="header-left">
      <h1 id="app-title">{{ web_ui_text.header_title or "Publisher V2 Web" }}</h1>
    </div>
    <div class="header-right">
      <span id="env-indicator" class="status"></span>
      <button id="btn-admin" class="secondary" type="button">
        {{ web_ui_text.buttons.admin or "Admin" }}
      </button>
      <button id="btn-admin-logout" class="secondary admin-only hidden" type="button">
        {{ web_ui_text.buttons.logout or "Logout" }}
      </button>
    </div>
  </header>

  <div id="admin-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="admin-modal-title">
    <div class="modal-dialog">
      <h2 id="admin-modal-title">{{ web_ui_text.admin_dialog.title or "Admin login" }}</h2>
      <p class="status" id="admin-modal-description">{{ web_ui_text.admin_dialog.description or "Enter the admin password to enable analysis and publishing." }}</p>
      <form id="admin-login-form">
        <input
          type="password"
          id="admin-password"
          placeholder="{{ web_ui_text.admin_dialog.password_placeholder or 'Admin password' }}"
          autocomplete="current-password"
          style="width: 100%; padding: 0.5rem; border-radius: 9999px; border: 1px solid #374151; background-color: #020617; color: #e5e7eb;"
        />
        <div class="modal-footer">
          <button type="button" id="admin-modal-close" class="secondary">Cancel</button>
          <button type="submit">Login</button>
        </div>
      </form>
      <div id="admin-message" class="status"></div>
    </div>
  </div>
  <main>
    <div class="mode-toggle">
      <button id="mode-publish" class="mode-btn active">Publish Mode</button>
      <button id="mode-review" class="mode-btn">Review Mode</button>
    </div>
    <div class="image-container">
      <div id="image-placeholder" class="image-placeholder">
        {{ web_ui_text.placeholders.image_empty or "No image loaded yet." }}
      </div>
      <img id="image" class="hidden" alt="No image loaded yet" />
      <div id="position-indicator" class="status hidden" style="position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,0.6); padding: 2px 6px; border-radius: 4px; font-size: 0.8rem; color: #e5e7eb;"></div>
    </div>

    <div class="controls">
      <button id="btn-prev" class="secondary hidden">Previous</button>
      <button id="btn-next">
        {{ web_ui_text.buttons.next or "Next image" }}
      </button>
      <button id="btn-fullsize" class="secondary hidden">
        {{ web_ui_text.buttons.fullsize or "ðŸ“¥ Full Size" }}
      </button>
      <div id="admin-controls" class="controls admin-only hidden">
        <button id="btn-analyze" class="secondary">
          {{ web_ui_text.buttons.analyze or "Analyze & caption" }}
        </button>
        <button id="btn-publish" class="secondary">
          {{ web_ui_text.buttons.publish or "Publish" }}
        </button>
        <button id="btn-keep" class="secondary">
          {{ web_ui_text.buttons.keep or "Keep" }}
        </button>
        <button id="btn-remove" class="secondary">
          {{ web_ui_text.buttons.remove or "Remove" }}
        </button>
      </div>
    </div>

    <div class="panel" id="panel-caption">
      <h2>{{ web_ui_text.panels.caption_title or "Caption" }}</h2>
      <div id="caption-text">{{ web_ui_text.placeholders.caption_empty or "No caption yet." }}</div>
    </div>

    <div class="panel admin-only hidden" id="panel-admin">
      <h2>{{ web_ui_text.panels.admin_title or "Administration" }}</h2>
      <div id="admin-mode-indicator" class="status">
        {{ web_ui_text.status.admin_mode_off or "Admin mode: off" }}
      </div>
      <div class="status">Admin-only controls are active while you are logged in.</div>
    </div>

    <div class="panel admin-only hidden" id="panel-activity">
      <h2>{{ web_ui_text.panels.activity_title or "Activity" }}</h2>
      <div id="status" class="status">
        {{ web_ui_text.status.ready or "Ready." }}
      </div>
      <div id="details"></div>
    </div>
  </main>

  <script>
    // i18n text injected from static config (YAML â†’ Jinja â†’ JS)
    const TEXT = {{ web_ui_text | tojson }};
    
    const bodyEl = document.body;
    const imgEl = document.getElementById("image");
    const imagePlaceholder = document.getElementById("image-placeholder");
    const statusEl = document.getElementById("status");
    const detailsEl = document.getElementById("details");
    const envIndicator = document.getElementById("env-indicator");
    const captionEl = document.getElementById("caption-text");
    const btnNext = document.getElementById("btn-next");
    const btnFullSize = document.getElementById("btn-fullsize");
    const btnAnalyze = document.getElementById("btn-analyze");
    const btnPublish = document.getElementById("btn-publish");
    const btnKeep = document.getElementById("btn-keep");
    const btnRemove = document.getElementById("btn-remove");
    const btnAdmin = document.getElementById("btn-admin");
    const btnAdminLogout = document.getElementById("btn-admin-logout");
    const adminControls = document.getElementById("admin-controls");
    const panelAdmin = document.getElementById("panel-admin");
    const panelActivity = document.getElementById("panel-activity");
    const adminModeIndicator = document.getElementById("admin-mode-indicator");
    const adminForm = document.getElementById("admin-login-form");
    const adminPasswordInput = document.getElementById("admin-password");
    const adminMessage = document.getElementById("admin-message");
    const adminModal = document.getElementById("admin-modal");
    const adminModalClose = document.getElementById("admin-modal-close");

    const modePublishBtn = document.getElementById("mode-publish");
    const modeReviewBtn = document.getElementById("mode-review");
    const btnPrev = document.getElementById("btn-prev");

    const imageContainer = document.querySelector(".image-container");
    const positionIndicator = document.getElementById("position-indicator");

    let currentFilename = null;
    let currentFullUrl = null;  // Store full-size URL for "Full Size" button
    let prefetchedImage = null; // Prefetched next image for instant loading (Story 03)
    let reviewList = [];
    let reviewIndex = -1;
    let currentMode = localStorage.getItem("pv2_mode") || "publish"; // "publish" or "review"

    let isAdmin = false;
    let featureConfig = {
      analyze_caption_enabled: true,
      publish_enabled: true,
      keep_enabled: true,
      remove_enabled: true,
      auto_view_enabled: false,
    };

    function updateModeUI() {
      if (currentMode === "review") {
        modePublishBtn.classList.remove("active");
        modeReviewBtn.classList.add("active");
        btnPrev.classList.remove("hidden");
        btnNext.textContent = "Next";
        positionIndicator.classList.remove("hidden");
      } else {
        modePublishBtn.classList.add("active");
        modeReviewBtn.classList.remove("active");
        btnPrev.classList.add("hidden");
        btnNext.textContent = TEXT.buttons?.next || "Next image";
        positionIndicator.classList.add("hidden");
      }
      localStorage.setItem("pv2_mode", currentMode);
    }

    async function switchMode(newMode) {
      if (currentMode === newMode) return;
      currentMode = newMode;
      updateModeUI();
      
      if (currentMode === "review") {
        await initReviewMode();
      } else {
        // Publish mode logic
        reviewList = [];
        reviewIndex = -1;
        await apiGetRandom();
      }
    }

    async function initReviewMode() {
      setActivity("Loading image list...");
      disableButtons(true);
      try {
        const res = await fetch("/api/images/list");
        if (!res.ok) throw new Error("Failed to fetch image list");
        const data = await res.json();
        reviewList = data.filenames || [];
        
        if (reviewList.length === 0) {
          showImagePlaceholder("No images found.");
          return;
        }

        // Try to find current image in list to sync position
        if (currentFilename) {
          const idx = reviewList.indexOf(currentFilename);
          if (idx !== -1) {
            reviewIndex = idx;
          } else {
            reviewIndex = 0;
            await loadReviewImage(reviewIndex);
          }
        } else {
          reviewIndex = 0;
          await loadReviewImage(reviewIndex);
        }
        updatePositionIndicator();
      } catch (e) {
        console.error(e);
        setActivity("Error loading list.");
      } finally {
        disableButtons(false);
      }
    }

    async function loadReviewImage(index) {
      if (index < 0 || index >= reviewList.length) return;
      
      const filename = reviewList[index];
      setActivity(`Loading ${filename}...`);
      disableButtons(true);
      
      try {
        // Check prefetch first
        if (prefetchedImage && prefetchedImage.filename === filename) {
           applyImageData(prefetchedImage);
           prefetchedImage = null;
        } else {
           const res = await fetch(`/api/images/${encodeURIComponent(filename)}`);
           if (!res.ok) throw new Error("Failed to load image");
           const data = await res.json();
           applyImageData(data);
        }
        reviewIndex = index;
        updatePositionIndicator();
        prefetchNextSequential();
      } catch (e) {
        console.error(e);
        setActivity(`Error loading ${filename}`);
      } finally {
        disableButtons(false);
      }
    }

    function applyImageData(data) {
        currentFilename = data.filename;
        const displayUrl = data.thumbnail_url || data.temp_url;
        showImage(
          displayUrl,
          data.temp_url,
          data.caption || data.sd_caption || data.filename
        );
        setCaption(data.caption || data.sd_caption || "No caption yet.");
        const meta = data.metadata ? JSON.stringify(data.metadata, null, 2) : "None";
        setDetails(`<div><strong>File:</strong> ${data.filename}</div><pre><code>${meta}</code></pre>`);
        setActivity("Image loaded.");
    }

    function updatePositionIndicator() {
      if (currentMode === "review" && reviewList.length > 0) {
        positionIndicator.textContent = `${reviewIndex + 1} / ${reviewList.length}`;
      } else {
        positionIndicator.textContent = "";
      }
    }

    async function prefetchNextSequential() {
      if (reviewIndex + 1 < reviewList.length) {
        const nextFilename = reviewList[reviewIndex + 1];
        try {
          const res = await fetch(`/api/images/${encodeURIComponent(nextFilename)}`);
          if (res.ok) {
            const data = await res.json();
            prefetchedImage = data;
            // Browser cache warming
            if (data.thumbnail_url) {
                const link = document.createElement("link");
                link.rel = "prefetch";
                link.as = "image";
                link.href = data.thumbnail_url;
                document.head.appendChild(link);
                setTimeout(() => link.remove(), 30000);
            }
          }
        } catch (e) { console.warn("Prefetch failed", e); }
      }
    }

    async function handleNext() {
      if (currentMode === "review") {
        if (reviewIndex + 1 < reviewList.length) {
          await loadReviewImage(reviewIndex + 1);
        } else {
          setActivity("End of list.");
        }
      } else {
        await apiGetRandom();
      }
    }

    async function handlePrev() {
      if (currentMode === "review") {
        if (reviewIndex > 0) {
          await loadReviewImage(reviewIndex - 1);
        } else {
          setActivity("Start of list.");
        }
      }
    }

    // Modify apiGetRandom to use applyImageData for consistency and handle new response shape
    async function apiGetRandom() {
      const adminReq = TEXT.status?.admin_required || "Admin mode required to view images.";
      
      if (!isAdmin && !featureConfig.auto_view_enabled) {
        setActivity(adminReq);
        setDetails("");
        showImagePlaceholder(adminReq);
        return;
      }
      
      if (prefetchedImage) {
        applyImageData(prefetchedImage);
        prefetchedImage = null;
        prefetchNextThumbnail(); // Original random prefetch
        return;
      }
      
      setActivity("Loading random imageâ€¦");
      disableButtons(true);
      try {
        const res = await fetch("/api/images/random");
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err.detail || err.error || "Failed to load image");
        }
        const data = await res.json();
        applyImageData(data);
        prefetchNextThumbnail();
      } catch (e) {
        console.error(e);
        currentFilename = null;
        showImagePlaceholder("Error loading image.");
        setCaption(null);
        setDetails("");
        setActivity(e.message || "Error loading image.");
      } finally {
        disableButtons(false);
      }
    }

    function setActivity(msg) {
      statusEl.textContent = msg || "";
    }

    function setDetails(html) {
      if (!isAdmin) {
        detailsEl.innerHTML = "<div>Admin-only details are hidden.</div>";
        return;
      }
      detailsEl.innerHTML = html || "";
    }

    function setCaption(text) {
      const fallback = TEXT.placeholders?.caption_empty || "No caption yet.";
      captionEl.textContent = text || fallback;
    }

    function showImagePlaceholder(message) {
      if (imgEl) {
        imgEl.src = "";
        imgEl.classList.add("hidden");
      }
      if (imagePlaceholder) {
        const fallback = TEXT.placeholders?.image_empty || "No image loaded yet.";
        imagePlaceholder.textContent = message || fallback;
        imagePlaceholder.classList.remove("hidden");
      }
      currentFullUrl = null;
      // Hide Full Size button when no image is loaded
      if (btnFullSize) {
        btnFullSize.classList.add("hidden");
      }
    }

    function handleFullSize() {
      if (currentFullUrl) {
        window.open(currentFullUrl, "_blank");
      }
    }

    function showImage(thumbnailUrl, fullUrl, altText) {
      if (imagePlaceholder) {
        imagePlaceholder.classList.add("hidden");
      }
      if (imgEl) {
        imgEl.src = thumbnailUrl;  // Load thumbnail (fast!)
        imgEl.alt = altText || "Image";
        imgEl.classList.remove("hidden");
      }
      currentFullUrl = fullUrl;
      // Show Full Size button when image is loaded
      if (btnFullSize) {
        btnFullSize.classList.remove("hidden");
      }
    }

    // Prefetch next image for instant loading during curation (Story 03)
    async function prefetchNextThumbnail() {
      // Only prefetch if user can view images
      if (!isAdmin && !featureConfig.auto_view_enabled) {
        prefetchedImage = null;
        return;
      }
      try {
        const res = await fetch("/api/images/random");
        if (!res.ok) {
          prefetchedImage = null;
          return;
        }
        const data = await res.json();
        prefetchedImage = data;
        
        // Prefetch thumbnail via link element (browser caches it)
        if (data.thumbnail_url) {
          const link = document.createElement("link");
          link.rel = "prefetch";
          link.as = "image";
          link.href = data.thumbnail_url;
          document.head.appendChild(link);
          // Clean up link after 30 seconds to prevent DOM bloat
          setTimeout(() => link.remove(), 30000);
        }
      } catch (e) {
        console.warn("Prefetch failed:", e);
        prefetchedImage = null;
      }
    }

    function disableButtons(disabled) {
      const nextShouldBeDisabled = disabled || (!isAdmin && !featureConfig.auto_view_enabled);
      btnNext.disabled = nextShouldBeDisabled;
      if (btnAnalyze) {
        btnAnalyze.disabled = disabled || !isAdmin || !featureConfig.analyze_caption_enabled;
      }
      if (btnPublish) {
        btnPublish.disabled = disabled || !isAdmin || !featureConfig.publish_enabled;
      }
    }

    async function fetchFeatureConfig() {
      try {
        const res = await fetch("/api/config/features");
        if (!res.ok) {
          console.warn("Failed to fetch feature config, defaulting to all enabled");
          return {
            analyze_caption_enabled: true,
            publish_enabled: true,
            keep_enabled: true,
            remove_enabled: true,
            auto_view_enabled: false,
          };
        }
        const data = await res.json();
        return {
          analyze_caption_enabled: data.analyze_caption_enabled ?? true,
          publish_enabled: data.publish_enabled ?? true,
          keep_enabled: data.keep_enabled ?? true,
          remove_enabled: data.remove_enabled ?? true,
          auto_view_enabled: data.auto_view_enabled ?? false,
        };
      } catch (error) {
        console.error("Error fetching feature config:", error);
        return {
          analyze_caption_enabled: true,
          publish_enabled: true,
          keep_enabled: true,
          remove_enabled: true,
          auto_view_enabled: false,
        };
      }
    }

    function updateAdminUI() {
      const onText = TEXT.status?.admin_mode_on || "Admin mode: on";
      const offText = TEXT.status?.admin_mode_off || "Admin mode: off";
      adminModeIndicator.textContent = isAdmin ? onText : offText;
      if (envIndicator) {
        envIndicator.textContent = featureConfig.auto_view_enabled
          ? "Viewer mode"
          : "Private mode";
      }
      if (isAdmin) {
        bodyEl.classList.add("admin-mode");
        adminControls.classList.remove("hidden");
        panelAdmin.classList.remove("hidden");
        panelActivity.classList.remove("hidden");
        btnAdmin.classList.add("hidden");
        btnAdminLogout.classList.remove("hidden");
      } else {
        bodyEl.classList.remove("admin-mode");
        adminControls.classList.add("hidden");
        panelAdmin.classList.add("hidden");
        panelActivity.classList.add("hidden");
        btnAdmin.classList.remove("hidden");
        btnAdminLogout.classList.add("hidden");
        detailsEl.innerHTML = "<div>Admin-only details are hidden.</div>";
      }
      if (btnAnalyze) {
        const shouldShowAnalyze = featureConfig.analyze_caption_enabled;
        btnAnalyze.classList.toggle("hidden", !shouldShowAnalyze);
        btnAnalyze.disabled = !isAdmin || !shouldShowAnalyze;
      }
      if (btnPublish) {
        const shouldShowPublish = featureConfig.publish_enabled;
        btnPublish.classList.toggle("hidden", !shouldShowPublish);
        btnPublish.disabled = !isAdmin || !shouldShowPublish;
      }
      if (btnKeep) {
        const shouldShowKeep = featureConfig.keep_enabled;
        btnKeep.classList.toggle("hidden", !shouldShowKeep);
        btnKeep.disabled = !isAdmin || !shouldShowKeep;
      }
      if (btnRemove) {
        const shouldShowRemove = featureConfig.remove_enabled;
        btnRemove.classList.toggle("hidden", !shouldShowRemove);
        btnRemove.disabled = !isAdmin || !shouldShowRemove;
      }
      // When AUTO_VIEW is disabled and user is not admin, replace the image
      // area with a clear login-required message instead of a broken image.
      if (!isAdmin && !featureConfig.auto_view_enabled) {
        showImagePlaceholder(TEXT.status?.admin_required || "Admin mode required to view images.");
      }
      // Ensure Next button reflects current admin + AUTO_VIEW state when not globally disabled.
      disableButtons(false);
    }

    async function fetchAdminStatus() {
      try {
        const res = await fetch("/api/admin/status");
        if (!res.ok) {
          return false;
        }
        const data = await res.json();
        return !!data.admin;
      } catch (e) {
        console.error(e);
        return false;
      }
    }

    function updateAdminState(admin) {
      isAdmin = !!admin;
      updateAdminUI();
    }

    async function refreshAdminStatus() {
      const admin = await fetchAdminStatus();
      updateAdminState(admin);
    }

    async function apiGetRandom() {
      const adminReq = TEXT.status?.admin_required || "Admin mode required to view images.";
      
      // Check permission first
      if (!isAdmin && !featureConfig.auto_view_enabled) {
        setActivity(adminReq);
        setDetails("");
        showImagePlaceholder(adminReq);
        return;
      }
      
      // Check for prefetched image (instant load path)
      if (prefetchedImage) {
        const data = prefetchedImage;
        prefetchedImage = null; // Consume the prefetch
        
        currentFilename = data.filename;
        const displayUrl = data.thumbnail_url || data.temp_url;
        showImage(
          displayUrl,
          data.temp_url,
          data.caption || data.sd_caption || data.filename
        );
        setCaption(data.caption || data.sd_caption || "No caption yet.");
        const meta = data.metadata ? JSON.stringify(data.metadata, null, 2) : "None";
        setDetails(`<div><strong>File:</strong> ${data.filename}</div><pre><code>${meta}</code></pre>`);
        setActivity("Image loaded (prefetched).");
        
        // Start prefetching the next image
        prefetchNextThumbnail();
        return;
      }
      
      // Cold start path: fetch from API
      setActivity("Loading random imageâ€¦");
      disableButtons(true);
      try {
        const res = await fetch("/api/images/random");
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err.detail || err.error || "Failed to load image");
        }
        const data = await res.json();
        currentFilename = data.filename;
        // Use thumbnail_url for display (fast), fallback to temp_url for backward compat
        const displayUrl = data.thumbnail_url || data.temp_url;
        showImage(
          displayUrl,
          data.temp_url,  // Store full URL for "Full Size" access
          data.caption || data.sd_caption || data.filename
        );
        setCaption(data.caption || data.sd_caption || "No caption yet.");
        const meta = data.metadata ? JSON.stringify(data.metadata, null, 2) : "None";
        setDetails(`<div><strong>File:</strong> ${data.filename}</div><pre><code>${meta}</code></pre>`);
        setActivity("Image loaded.");
        
        // Start prefetching the next image
        prefetchNextThumbnail();
      } catch (e) {
        console.error(e);
        currentFilename = null;
        showImagePlaceholder("Error loading image.");
        setCaption(null);
        setDetails("");
        setActivity(e.message || "Error loading image.");
      } finally {
        disableButtons(false);
      }
    }

    async function apiAnalyze() {
      if (!currentFilename) {
        setActivity("No image selected.");
        return;
      }
      if (!isAdmin) {
        setActivity("Admin mode required to analyze.");
        return;
      }
      setActivity("Analyzing imageâ€¦");
      disableButtons(true);
      try {
        const res = await fetch(`/api/images/${encodeURIComponent(currentFilename)}/analyze`, {
          method: "POST",
          headers: { "Content-Type": "application/json" }
        });
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          if (res.status === 401 || res.status === 403) {
            updateAdminState(false);
            throw new Error("Admin session expired, please log in again.");
          }
          throw new Error(err.detail || err.error || "Failed to analyze image");
        }
        const data = await res.json();
        setCaption(data.caption || data.sd_caption || "No caption generated.");
        const meta = {
          description: data.description,
          mood: data.mood,
          nsfw: data.nsfw,
          tags: data.tags
        };
        setDetails(`<div><strong>Analysis:</strong></div><pre><code>${JSON.stringify(meta, null, 2)}</code></pre>`);
        setActivity("Analysis complete; caption generated.");
      } catch (e) {
        console.error(e);
        const msg = e.message || "Error analyzing image.";
        setActivity(msg);
      } finally {
        disableButtons(false);
      }
    }

    async function apiPublish() {
      if (!currentFilename) {
        setActivity("No image selected.");
        return;
      }
      if (!isAdmin) {
        setActivity("Admin mode required to publish.");
        return;
      }
      setActivity("Publishing imageâ€¦");
      disableButtons(true);
      try {
        const res = await fetch(`/api/images/${encodeURIComponent(currentFilename)}/publish`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({})
        });
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          if (res.status === 401 || res.status === 403) {
            updateAdminState(false);
            throw new Error("Admin session expired, please log in again.");
          }
          throw new Error(err.detail || err.error || "Failed to publish image");
        }
        const data = await res.json();
        const results = JSON.stringify(data.results || {}, null, 2);
        setDetails(`<div><strong>Publish results:</strong></div><pre><code>${results}</code></pre>`);
        if (data.any_success) {
          setActivity(`Publish complete${data.archived ? " and archived." : "."}`);
        } else {
          setActivity("Publish completed but no platforms reported success; see details.");
        }
      } catch (e) {
        console.error(e);
        const msg = e.message || "Error publishing image.";
        setActivity(msg);
      } finally {
        disableButtons(false);
      }
    }

    async function apiKeep() {
      if (!currentFilename) {
        setActivity("No image selected.");
        return;
      }
      if (!isAdmin) {
        setActivity("Admin mode required to keep.");
        return;
      }
      setActivity("Keeping imageâ€¦");
      disableButtons(true);
      try {
        const res = await fetch(`/api/images/${encodeURIComponent(currentFilename)}/keep`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
        });
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          if (res.status === 401 || res.status === 403) {
            updateAdminState(false);
            throw new Error("Admin session expired or keep disabled, please log in again.");
          }
          throw new Error(err.detail || err.error || "Failed to keep image");
        }
        const data = await res.json();
        setActivity(`Moved to keep: ${data.filename} â†’ ${data.destination_folder || "(configured keep folder)"}.`);
        // After a successful keep, advance to the next image.
        await apiGetRandom();
      } catch (e) {
        console.error(e);
        const msg = e.message || "Error keeping image.";
        setActivity(msg);
      } finally {
        disableButtons(false);
      }
    }

    async function apiRemove() {
      if (!currentFilename) {
        setActivity("No image selected.");
        return;
      }
      if (!isAdmin) {
        setActivity("Admin mode required to remove.");
        return;
      }
      setActivity("Removing imageâ€¦");
      disableButtons(true);
      try {
        const res = await fetch(`/api/images/${encodeURIComponent(currentFilename)}/remove`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
        });
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          if (res.status === 401 || res.status === 403) {
            updateAdminState(false);
            throw new Error("Admin session expired or remove disabled, please log in again.");
          }
          throw new Error(err.detail || err.error || "Failed to remove image");
        }
        const data = await res.json();
        setActivity(
          `Moved to remove folder (not deleted): ${data.filename} â†’ ${data.destination_folder || "(configured remove folder)"}`
        );
        // After a successful remove, advance to the next image.
        await apiGetRandom();
      } catch (e) {
        console.error(e);
        const msg = e.message || "Error removing image.";
        setActivity(msg);
      } finally {
        disableButtons(false);
      }
    }

    async function handleAdminLogin(event) {
      event.preventDefault();
      adminMessage.textContent = "";
      const password = adminPasswordInput.value || "";
      if (!password) {
        adminMessage.textContent = "Please enter the admin password.";
        return;
      }
      try {
        const res = await fetch("/api/admin/login", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ password }),
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok || !data.admin) {
          isAdmin = false;
          adminMessage.textContent = data.detail || data.error || "Invalid admin password.";
        } else {
          updateAdminState(true);
          adminMessage.textContent = "Admin mode enabled.";
          setActivity("Admin mode enabled.");
          adminModal.classList.add("hidden");
          // After successful admin login, immediately load an image so the
          // placeholder does not keep showing a login-required message.
          await apiGetRandom();
        }
      } catch (e) {
        console.error(e);
        isAdmin = false;
        adminMessage.textContent = "Error logging in as admin.";
      } finally {
        adminPasswordInput.value = "";
      }
    }

    async function handleAdminLogout() {
      adminMessage.textContent = "";
      try {
        const res = await fetch("/api/admin/logout", {
          method: "POST",
        });
        if (!res.ok) {
          const data = await res.json().catch(() => ({}));
          adminMessage.textContent = data.detail || data.error || "Error logging out of admin mode.";
        } else {
          updateAdminState(false);
          adminMessage.textContent = "Admin mode disabled.";
          setActivity("Admin mode disabled.");
        }
      } catch (e) {
        console.error(e);
        adminMessage.textContent = "Error logging out of admin mode.";
      } finally {
      }
    }

    function initAdminControls() {
      btnAdmin.addEventListener("click", () => {
        adminModal.classList.remove("hidden");
        adminPasswordInput.focus();
      });
      adminModalClose.addEventListener("click", () => {
        adminModal.classList.add("hidden");
        adminMessage.textContent = "";
      });
      adminModal.addEventListener("click", (event) => {
        if (event.target === adminModal) {
          adminModal.classList.add("hidden");
          adminMessage.textContent = "";
        }
      });
      adminForm.addEventListener("submit", handleAdminLogin);
      btnAdminLogout.addEventListener("click", handleAdminLogout);
    }

    function initGestures() {
      let touchStartX = 0;
      let touchStartY = 0;
      let touchEndX = 0;
      let touchEndY = 0;
      const SWIPE_THRESHOLD = 50;

      imageContainer.addEventListener('touchstart', (e) => {
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
      }, { passive: true });

      imageContainer.addEventListener('touchend', (e) => {
        touchEndX = e.changedTouches[0].screenX;
        touchEndY = e.changedTouches[0].screenY;
        handleSwipe();
      }, { passive: true });

      function handleSwipe() {
        const diffX = touchStartX - touchEndX;
        const diffY = touchStartY - touchEndY;

        // Check for horizontal dominance
        if (Math.abs(diffX) > Math.abs(diffY)) {
           // Horizontal swipe
           if (Math.abs(diffX) > SWIPE_THRESHOLD) {
             if (diffX > 0) {
               // Swipe Left -> Next
               imageContainer.classList.add("swiping-left");
               setTimeout(() => imageContainer.classList.remove("swiping-left"), 300);
               handleNext();
             } else {
               // Swipe Right -> Previous (if allowed)
               if (currentMode === "review") {
                 imageContainer.classList.add("swiping-right");
                 setTimeout(() => imageContainer.classList.remove("swiping-right"), 300);
                 handlePrev();
               }
             }
           }
        }
      }
    }

    function initLayout() {
      btnNext.addEventListener("click", handleNext);
      btnPrev.addEventListener("click", handlePrev);
      
      modePublishBtn.addEventListener("click", () => switchMode("publish"));
      modeReviewBtn.addEventListener("click", () => switchMode("review"));

      if (btnFullSize) {
        btnFullSize.addEventListener("click", handleFullSize);
      }
      if (btnAnalyze) {
        btnAnalyze.addEventListener("click", apiAnalyze);
      }
      if (btnPublish) {
        btnPublish.addEventListener("click", apiPublish);
      }
      if (btnKeep) {
        btnKeep.addEventListener("click", apiKeep);
      }
      if (btnRemove) {
        btnRemove.addEventListener("click", apiRemove);
      }
      initAdminControls();
      initGestures();
      window.addEventListener("load", async () => {
        // Fetch feature config first so we can gate buttons from .env feature flags.
        featureConfig = await fetchFeatureConfig();
        await refreshAdminStatus();
        updateAdminUI();
        updateModeUI();

        if (isAdmin || featureConfig.auto_view_enabled) {
          if (currentMode === "review") {
            await initReviewMode();
          } else {
            await apiGetRandom();
          }
        } else {
          setActivity("Ready. Admin mode required to view images.");
          setDetails("");
          showImagePlaceholder("Admin mode required to view images.");
        }
      });
    }

    initLayout();
  </script>
</body>
</html>


